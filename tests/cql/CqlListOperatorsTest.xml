<?xml version="1.0" encoding="utf-8"?>
<tests xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://hl7.org/fhirpath/tests" xsi:schemaLocation="http://hl7.org/fhirpath/tests ../../testSchema/testSchema.xsd"
	name="CqlListOperatorsTest" reference="https://cql.hl7.org/09-b-cqlreference.html#list-operators-2" version="1.0">
	<capability code="list-operators" />
	<group name="Sort" version="1.0">
		<capability code="list-operators" />
		<test name="simpleSortAsc" version="1.0">
			<capability code="list-operators" />
			<expression>({4, 5, 1, 6, 2, 1}) sL sort asc</expression>
			<output>{1, 1, 2, 4, 5, 6}</output>
		</test>
		<test name="simpleSortDesc" version="1.0">
			<capability code="list-operators" />
			<expression>({4, 5, 1, 6, 2, 1}) sL sort desc</expression>
			<output>{6, 5, 4, 2, 1, 1}</output>
		</test>
		<test name="simpleSortStringAsc" version="1.0">
			<capability code="list-operators" />
			<expression>({'back', 'aardvark', 'alligator', 'zebra', 'iguana', 'Wolf', 'Armadillo'}) sls sort asc</expression>
			<output>{'Armadillo', 'Wolf', 'aardvark', 'alligator', 'back', 'iguana', 'zebra'}</output>
		</test>
		<test name="simpleSortStringDesc" version="1.0">
			<capability code="list-operators" />
			<expression>({'back', 'aardvark', 'alligator', 'zebra', 'iguana', 'Wolf', 'Armadillo'}) sls sort desc</expression>
			<output>{'zebra', 'iguana', 'back', 'alligator', 'aardvark', 'Wolf', 'Armadillo'}</output>
		</test>
		<test name="SortDatesAsc" version="1.0">
			<capability code="list-operators" />
			<expression>({ DateTime(2012, 10, 5, 10), DateTime(2012, 1, 1), DateTime(2012, 1, 1, 12), DateTime(2012, 10, 5) }) S sort asc</expression>
			<output>{ @2012-01-01T, @2012-01-01T12, @2012-10-05T, @2012-10-05T10 }</output>
		</test>
		<test name="SortDatesDesc" version="1.0">
			<capability code="list-operators" />
			<expression>({ DateTime(2012, 10, 5, 10), DateTime(2012, 1, 1), DateTime(2012, 1, 1, 12), DateTime(2012, 10, 5) }) S sort desc</expression>
			<output>{ @2012-10-05T10, @2012-10-05T, @2012-01-01T12, @2012-01-01T }</output>
		</test>
		<test name="intList" version="1.0">
			<capability code="list-operators" />
			<expression>{ 3, 2, 1 }</expression>
			<output>{3, 2, 1}</output>
		</test>
		<test name="decimalList" version="1.0">
			<capability code="list-operators" />
			<expression>{ 3.8, 2.4, 1.9 }</expression>
			<output>{3.8, 2.4, 1.9}</output>
		</test>
		<test name="quantityList" version="1.0">
			<capability code="list-operators" />
			<expression>{ 19.99 '[lb_av]', 17.33 '[lb_av]', 10.66 '[lb_av]' }</expression>
			<output>{19.99 '[lb_av]', 17.33 '[lb_av]', 10.66 '[lb_av]'}</output>
		</test>
		<test name="dateTimeList" version="1.0">
			<capability code="list-operators" />
			<expression>{ DateTime(2016), DateTime(2015), DateTime(2010) }</expression>
			<output>{@2016T, @2015T, @2010T}</output>
		</test>
		<test name="timeList" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T15:12:59.999, @T15:12:13.999 }</expression>
			<output>{@T15:59:59.999, @T15:12:59.999, @T15:12:13.999}</output>
		</test>
	</group>
	<group name="Contains" version="1.0">
		<capability code="list-operators" />
		<test name="ContainsABNullHasNull" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', null } contains null</expression>
			<output>true</output>
		</test>
		<test name="ContainsNullFirst" version="1.0">
			<capability code="list-operators" />
			<expression>{ null, 'b', 'c' } contains 'a'</expression>
			<output>false</output>
		</test>
		<test name="ContainsABCHasA" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } contains 'a'</expression>
			<output>true</output>
		</test>
		<test name="ContainsJan2012True" version="1.0">
			<capability code="list-operators" />
			<expression>{ DateTime(2012, 10, 5), DateTime(2012, 9, 5), DateTime(2012, 1, 1) } contains DateTime(2012, 1, 1)</expression>
			<output>true</output>
		</test>
		<test name="ContainsJan2012False" version="1.0">
			<capability code="list-operators" />
			<expression>{ DateTime(2012, 10, 5), DateTime(2012, 9, 5), DateTime(2012, 10, 1) } contains DateTime(2012, 1, 1)</expression>
			<output>false</output>
		</test>
		<test name="ContainsTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T05:59:59.999, @T20:59:59.999 } contains @T05:59:59.999</expression>
			<output>true</output>
		</test>
		<test name="ContainsTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T05:59:59.999, @T20:59:59.999 } contains @T08:59:59.999</expression>
			<output>false</output>
		</test>
		<test name="ContainsNullLeft" version="1.0">
			<capability code="list-operators" />
			<expression>null contains 'a'</expression>
			<output>false</output>
		</test>
	</group>
	<group name="Descendents" version="1.0">
		<capability code="list-operators" />
		<test name="DescendentsEmptyList" version="1.0">
			<capability code="list-operators" />
			<expression>(null).descendents()</expression>
			<output>null</output>
		</test>
		<!-- TODO: how to call without fhirpath syntax -->
	</group>
	<group name="Distinct" version="1.0">
		<capability code="list-operators" />
		<test name="DistinctEmptyList" version="1.0">
			<capability code="list-operators" />
			<expression>distinct {}</expression>
			<output>{}</output>
		</test>
		<test name="DistinctNullNullNull" version="1.0">
			<capability code="list-operators" />
			<expression>distinct { null, null, null}</expression>
			<output>{ null }</output>
		</test>
		<test name="DistinctANullANull" version="1.0">
			<capability code="list-operators" />
			<expression>distinct { 'a', null, 'a', null}</expression>
			<output>{'a', null}</output>
		</test>
		<test name="Distinct112233" version="1.0">
			<capability code="list-operators" />
			<expression>distinct { 1, 1, 2, 2, 3, 3}</expression>
			<output>{1,2,3}</output>
		</test>
		<test name="Distinct123123" version="1.0">
			<capability code="list-operators" />
			<expression>distinct { 1, 2, 3, 1, 2, 3}</expression>
			<output>{1,2,3}</output>
		</test>
		<test name="DistinctAABBCC" version="1.0">
			<capability code="list-operators" />
			<expression>distinct { 'a', 'a', 'b', 'b', 'c', 'c'}</expression>
			<output>{'a','b','c'}</output>
		</test>
		<test name="DistinctABCABC" version="1.0">
			<capability code="list-operators" />
			<expression>distinct { 'a', 'b', 'c', 'a', 'b', 'c'}</expression>
			<output>{'a','b','c'}</output>
		</test>
		<test name="DistinctDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>distinct { DateTime(2012, 10, 5), DateTime(2012, 1, 1), DateTime(2012, 1, 1)}</expression>
			<output>{ @2012-10-05T, @2012-01-01T }</output>
		</test>
		<test name="DistinctTime" version="1.0">
			<capability code="list-operators" />
			<expression>distinct { @T15:59:59.999, @T20:59:59.999 }</expression>
			<output>{ @T15:59:59.999, @T20:59:59.999 }</output>
		</test>
	</group>
	<group name="Equal" version="1.0">
		<capability code="list-operators" />
		<test name="EqualNullNull" version="1.0">
			<capability code="list-operators" />
			<expression>{null} = {null}</expression>
			<output>true</output>
		</test>
		<test name="EqualEmptyListNull" version="1.0">
			<capability code="list-operators" />
			<expression>{} as List&lt;String&gt; = null</expression>
			<output>null</output>
		</test>
		<test name="EqualNullEmptyList" version="1.0">
			<capability code="list-operators" />
			<expression>null = {} as List&lt;String&gt;</expression>
			<output>null</output>
		</test>
		<test name="EqualEmptyListAndEmptyList" version="1.0">
			<capability code="list-operators" />
			<expression>{} = {}</expression>
			<output>true</output>
		</test>
		<test name="EqualABCAndABC" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } = { 'a', 'b', 'c' }</expression>
			<output>true</output>
		</test>
		<test name="EqualABCAndAB" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } = { 'a', 'b' }</expression>
			<output>false</output>
		</test>
		<test name="EqualABCAnd123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } = { 1, 2, 3 }</expression>
			<output>false</output>
		</test>
		<test name="Equal123AndABC" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } = { 'a', 'b', 'c' }</expression>
			<output>false</output>
		</test>
		<test name="Equal123AndString123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } = { '1', '2', '3' }</expression>
			<output>false</output>
		</test>
		<test name="Equal12And123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2 } = { 1, 2, 3 }</expression>
			<output>false</output>
		</test>
		<test name="Equal123And12" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } = { 1, 2 }</expression>
			<output>false</output>
		</test>
		<test name="Equal123And123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } = { 1, 2, 3 }</expression>
			<output>true</output>
		</test>
		<test name="EqualDateTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2012, 5, 10, 0, 0, 0, 0), DateTime(2014, 12, 10, 0, 0, 0, 0)} = {DateTime(2012, 5, 10, 0, 0, 0, 0), DateTime(2014, 12, 10, 0, 0, 0, 0)}</expression>
			<output>true</output>
		</test>
		<test name="EqualDateTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2012, 5, 10, 0, 0, 0, 0), DateTime(2014, 12, 10, 0, 0, 0, 0)} = {DateTime(2012, 1, 10, 0, 0, 0, 0), DateTime(2014, 12, 10, 0, 0, 0, 0)}</expression>
			<output>false</output>
		</test>
		<test name="EqualTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999, @T20:59:59.999 } = { @T15:59:59.999, @T20:59:59.999, @T20:59:59.999 }</expression>
			<output>true</output>
		</test>
		<test name="EqualTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999, @T20:59:59.999 } = { @T10:59:59.999, @T20:59:59.999, @T20:59:59.999 }</expression>
			<output>false</output>
		</test>
	</group>
	<group name="Except" version="1.0">
		<capability code="list-operators" />
		<test name="ExceptEmptyListAndEmptyList" version="1.0">
			<capability code="list-operators" />
			<expression>{} except {}</expression>
			<output>{}</output>
		</test>
		<test name="Except1234And23" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3, 4 } except { 2, 3 }</expression>
			<output>{ 1, 4 }</output>
		</test>
		<test name="Except23And1234" version="1.0">
			<capability code="list-operators" />
			<expression>{ 2, 3 } except { 1, 2, 3, 4 }</expression>
			<output>{}</output>
		</test>
		<test name="ExceptDateTimeList" version="1.0">
			<capability code="list-operators" />
			<expression>{ DateTime(2012, 5, 10), DateTime(2014, 12, 10), DateTime(2010, 1, 1)} except {DateTime(2014, 12, 10), DateTime(2010, 1, 1) }</expression>
			<output>{@2012-05-10T}</output>
		</test>
		<test name="ExceptTimeList" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999, @T12:59:59.999 } except { @T20:59:59.999, @T12:59:59.999 }</expression>
			<output>{@T15:59:59.999}</output>
		</test>
		<test name="ExceptNullRight" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 4 } except null</expression>
			<output>{1, 4}</output>
		</test>
	</group>
	<group name="Exists" version="1.0">
		<capability code="list-operators" />
		<test name="ExistsEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>Exists({})</expression>
			<output>false</output>
		</test>
		<test name="ExistsListNull" version="1.0">
			<capability code="list-operators" />
			<expression>Exists({ null })</expression>
			<output>false</output>
		</test>
		<test name="Exists1" version="1.0">
			<capability code="list-operators" />
			<expression>Exists({ 1 })</expression>
			<output>true</output>
		</test>
		<test name="Exists12" version="1.0">
			<capability code="list-operators" />
			<expression>Exists({ 1, 2 })</expression>
			<output>true</output>
		</test>
		<test name="ExistsDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>Exists({ DateTime(2012, 5, 10), DateTime(2014, 12, 10) })</expression>
			<output>true</output>
		</test>
		<test name="ExistsTime" version="1.0">
			<capability code="list-operators" />
			<expression>Exists({ @T15:59:59.999, @T20:59:59.999 })</expression>
			<output>true</output>
		</test>
		<test name="ExistsNull" version="1.0">
			<capability code="list-operators" />
			<expression>Exists(null)</expression>
			<output>false</output>
		</test>
	</group>
	<group name="Flatten" version="1.0">
		<capability code="list-operators" />
		<test name="FlattenEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>Flatten({{},{}})</expression>
			<output>{}</output>
		</test>
		<test name="FlattenListNullAndNull" version="1.0">
			<capability code="list-operators" />
			<expression>Flatten({{null}, {null}})</expression>
			<output>{null, null}</output>
		</test>
		<test name="FlattenList12And34" version="1.0">
			<capability code="list-operators" />
			<expression>Flatten({{1,2}, {3,4}})</expression>
			<output>{1,2,3,4}</output>
		</test>
		<test name="FlattenDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>Flatten({ {DateTime(2012, 5, 10)}, {DateTime(2014, 12, 10)} })</expression>
			<output>{ @2012-05-10T, @2014-12-10T }</output>
		</test>
		<test name="FlattenTime" version="1.0">
			<capability code="list-operators" />
			<expression>Flatten({ {@T15:59:59.999}, {@T20:59:59.999} })</expression>
			<output>{ @T15:59:59.999, @T20:59:59.999 }</output>
		</test>
	</group>
	<group name="First" version="1.0">
		<capability code="list-operators" />
		<test name="FirstEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>First({})</expression>
			<output>null</output>
		</test>
		<test name="FirstNull1" version="1.0">
			<capability code="list-operators" />
			<expression>First({ null, 1 })</expression>
			<output>null</output>
		</test>
		<test name="First1Null" version="1.0">
			<capability code="list-operators" />
			<expression>First({ 1, null })</expression>
			<output>1</output>
		</test>
		<test name="First12" version="1.0">
			<capability code="list-operators" />
			<expression>First({ 1, 2 })</expression>
			<output>1</output>
		</test>
		<test name="FirstDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>First({ DateTime(2012, 5, 10), DateTime(2014, 12, 10) })</expression>
			<output>@2012-05-10T</output>
		</test>
		<test name="FirstTime" version="1.0">
			<capability code="list-operators" />
			<expression>First({ @T15:59:59.999, @T20:59:59.999 })</expression>
			<output>@T15:59:59.999</output>
		</test>
	</group>
	<group name="In" version="1.0">
		<capability code="list-operators" />
		<test name="InNullEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>null in {}</expression>
			<output>false</output>
		</test>
		<test name="InNullAnd1Null" version="1.0">
			<capability code="list-operators" />
			<expression>null in { 1, null }</expression>
			<output>true</output>
		</test>
		<test name="In1Null" version="1.0">
			<capability code="list-operators" />
			<expression>1 in null</expression>
			<output>false</output>
		</test>
		<test name="In1And12" version="1.0">
			<capability code="list-operators" />
			<expression>1 in { 1, 2 }</expression>
			<output>true</output>
		</test>
		<test name="In3And12" version="1.0">
			<capability code="list-operators" />
			<expression>3 in { 1, 2 }</expression>
			<output>false</output>
		</test>
		<test name="InDateTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>DateTime(2012, 5, 10) in { DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10) }</expression>
			<output>true</output>
		</test>
		<test name="InDateTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>DateTime(2012, 6, 10) in { DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10) }</expression>
			<output>false</output>
		</test>
		<test name="InTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>@T15:59:59.999 in { @T02:29:15.156, @T15:59:59.999, @T20:59:59.999 }</expression>
			<output>true</output>
		</test>
		<test name="InTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>@T16:59:59.999 in { @T02:29:15.156, @T15:59:59.999, @T20:59:59.999 }</expression>
			<output>false</output>
		</test>
	</group>
	<group name="Includes" version="1.0">
		<capability code="list-operators" />
		<test name="IncludesEmptyAndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{} includes {}</expression>
			<output>true</output>
		</test>
		<test name="IncludesListNullAndListNull" version="1.0">
			<capability code="list-operators" />
			<expression>{null} includes {null}</expression>
			<output>true</output>
		</test>
		<test name="Includes123AndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{1, 2, 3} includes {}</expression>
			<output>true</output>
		</test>
		<test name="Includes123And2" version="1.0">
			<capability code="list-operators" />
			<expression>{1, 2, 3} includes {2}</expression>
			<output>true</output>
		</test>
		<test name="Includes123And4" version="1.0">
			<capability code="list-operators" />
			<expression>{1, 2, 3} includes {4}</expression>
			<output>false</output>
		</test>
		<test name="IncludesDateTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)} includes {DateTime(2012, 5, 10)}</expression>
			<output>true</output>
		</test>
		<test name="IncludesDateTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)} includes {DateTime(2012, 5, 11)}</expression>
			<output>false</output>
		</test>
		<test name="IncludesTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T02:29:15.156, @T15:59:59.999, @T20:59:59.999 } includes @T15:59:59.999</expression>
			<output>true</output>
		</test>
		<test name="IncludesTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T02:29:15.156, @T15:59:59.999, @T20:59:59.999 } includes @T16:59:59.999</expression>
			<output>false</output>
		</test>
		<test name="IncludesNullLeft" version="1.0">
			<capability code="list-operators" />
			<expression>null includes {2}</expression>
			<output>null</output>
		</test>
		<!-- this test is going to the ContainsEvaluator -->
		<test name="IncludesNullRight" version="1.0">
			<capability code="list-operators" />
			<expression>{'s', 'a', 'm'} includes null</expression>
			<output>null</output>
		</test>
	</group>
	<group name="IncludedIn" version="1.0">
		<capability code="list-operators" />
		<test name="IncludedInEmptyAndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{} included in {}</expression>
			<output>true</output>
		</test>
		<test name="IncludedInListNullAndListNull" version="1.0">
			<capability code="list-operators" />
			<expression>{ null } included in { null }</expression>
			<output>true</output>
		</test>
		<test name="IncludedInEmptyAnd123" version="1.0">
			<capability code="list-operators" />
			<expression>{} included in { 1, 2, 3 }</expression>
			<output>true</output>
		</test>
		<test name="IncludedIn2And123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 2 } included in { 1, 2, 3 }</expression>
			<output>true</output>
		</test>
		<test name="IncludedIn4And123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 4 } included in { 1, 2, 3 }</expression>
			<output>false</output>
		</test>
		<test name="IncludedInDateTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{ DateTime(2012, 5, 10)} included in {DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)}</expression>
			<output>true</output>
		</test>
		<test name="IncludedInDateTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2012, 5, 11)} included in {DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)}</expression>
			<output>false</output>
		</test>
		<test name="IncludedInTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>@T15:59:59.999 included in { @T02:29:15.156, @T15:59:59.999, @T20:59:59.999 }</expression>
			<output>true</output>
		</test>
		<test name="IncludedInTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>@T16:59:59.999 included in { @T02:29:15.156, @T15:59:59.999, @T20:59:59.999 }</expression>
			<output>false</output>
		</test>
		<!-- the following expression is going to the InEvaluator -->
		<test name="IncludedInNullLeft" version="1.0">
			<capability code="list-operators" />
			<expression>null included in {2}</expression>
			<output>null</output>
		</test>
		<test name="IncludedInNullRight" version="1.0">
			<capability code="list-operators" />
			<expression>{'s', 'a', 'm'} included in null</expression>
			<output>null</output>
		</test>
	</group>
	<group name="Indexer" version="1.0">
		<capability code="list-operators" />
		<test name="IndexerNull1List" version="1.0">
			<capability code="list-operators" />
			<expression>(null as List&lt;System.Any&gt;)[1]</expression>
			<output>null</output>
		</test>
		<!-- Cast is required due to ambiguity with Indexer(String) and Indexer(List&lt;Any&gt;) -->
		<test name="Indexer0Of12" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2 }[0]</expression>
			<output>1</output>
		</test>
		<test name="Indexer1Of12" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2 }[1]</expression>
			<output>2</output>
		</test>
		<test name="Indexer2Of12" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2 }[2]</expression>
			<output>null</output>
		</test>
		<test name="IndexerNeg1Of12" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2 }[-1]</expression>
			<output>null</output>
		</test>
		<test name="IndexerDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>{ DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10) }[1]</expression>
			<output>@2012-05-10T</output>
		</test>
		<test name="IndexerTime" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T02:29:15.156, @T15:59:59.999, @T20:59:59.999 }[1]</expression>
			<output>@T15:59:59.999</output>
		</test>
	</group>
	<group name="IndexOf" version="1.0">
		<capability code="list-operators" />
		<test name="IndexOfEmptyNull" version="1.0">
			<capability code="list-operators" />
			<expression>IndexOf({}, null)</expression>
			<output>null</output>
		</test>
		<test name="IndexOfNullEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>IndexOf(null, {})</expression>
			<output>null</output>
		</test>
		<test name="IndexOfNullIn1Null" version="1.0">
			<capability code="list-operators" />
			<expression>IndexOf({ 1, null }, null)</expression>
			<output>null</output>
		</test>
		<test name="IndexOf1In12" version="1.0">
			<capability code="list-operators" />
			<expression>IndexOf({ 1, 2 }, 1)</expression>
			<output>0</output>
		</test>
		<test name="IndexOf2In12" version="1.0">
			<capability code="list-operators" />
			<expression>IndexOf({ 1, 2 }, 2)</expression>
			<output>1</output>
		</test>
		<test name="IndexOf3In12" version="1.0">
			<capability code="list-operators" />
			<expression>IndexOf({ 1, 2 }, 3)</expression>
			<output>-1</output>
		</test>
		<test name="IndexOfDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>IndexOf({ DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10) }, DateTime(2014, 12, 10))</expression>
			<output>2</output>
		</test>
		<test name="IndexOfTime" version="1.0">
			<capability code="list-operators" />
			<expression>IndexOf({ @T02:29:15.156, @T15:59:59.999, @T20:59:59.999 }, @T15:59:59.999)</expression>
			<output>1</output>
		</test>
	</group>
	<group name="Intersect" version="1.0">
		<capability code="list-operators" />
		<test name="IntersectEmptyListAndEmptyList" version="1.0">
			<capability code="list-operators" />
			<expression>{} intersect {}</expression>
			<output>{}</output>
		</test>
		<test name="Intersect1234And23" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3, 4 } intersect { 2, 3 }</expression>
			<output>{ 2, 3 }</output>
		</test>
		<test name="Intersect23And1234" version="1.0">
			<capability code="list-operators" />
			<expression>{2, 3} intersect { 1, 2, 3, 4 }</expression>
			<output>{ 2, 3 }</output>
		</test>
		<test name="IntersectDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>{ DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10) } intersect { DateTime(2012, 5, 10), DateTime(2014, 12, 10), DateTime(2000, 5, 5) }</expression>
			<output>{@2012-05-10T, @2014-12-10T}</output>
		</test>
		<test name="IntersectTime" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T02:29:15.156, @T15:59:59.999, @T20:59:59.999 } intersect { @T01:29:15.156, @T15:59:59.999, @T20:59:59.999 }</expression>
			<output>{@T15:59:59.999, @T20:59:59.999}</output>
		</test>
	</group>
	<group name="Last" version="1.0">
		<capability code="list-operators" />
		<test name="LastEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>Last({})</expression>
			<output>null</output>
		</test>
		<test name="LastNull1" version="1.0">
			<capability code="list-operators" />
			<expression>Last({null, 1})</expression>
			<output>1</output>
		</test>
		<test name="Last1Null" version="1.0">
			<capability code="list-operators" />
			<expression>Last({1, null})</expression>
			<output>null</output>
		</test>
		<test name="Last12" version="1.0">
			<capability code="list-operators" />
			<expression>Last({1, 2})</expression>
			<output>2</output>
		</test>
		<test name="LastDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>Last({DateTime(2012, 5, 10), DateTime(2014, 12, 10)})</expression>
			<output>@2014-12-10T</output>
		</test>
		<test name="LastTime" version="1.0">
			<capability code="list-operators" />
			<expression>Last({ @T15:59:59.999, @T20:59:59.999 })</expression>
			<output>@T20:59:59.999</output>
		</test>
	</group>
	<group name="Length" version="1.0">
		<capability code="list-operators" />
		<test name="LengthEmptyList" version="1.0">
			<capability code="list-operators" />
			<expression>Length({})</expression>
			<output>0</output>
		</test>
		<test name="LengthNull1" version="1.0">
			<capability code="list-operators" />
			<expression>Length({null, 1})</expression>
			<output>2</output>
		</test>
		<test name="Length1Null" version="1.0">
			<capability code="list-operators" />
			<expression>Length({1, null})</expression>
			<output>2</output>
		</test>
		<test name="Length12" version="1.0">
			<capability code="list-operators" />
			<expression>Length({1, 2})</expression>
			<output>2</output>
		</test>
		<test name="LengthDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>Length({DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)})</expression>
			<output>3</output>
		</test>
		<test name="LengthTime" version="1.0">
			<capability code="list-operators" />
			<expression>Length({ @T15:59:59.999, @T20:59:59.999, @T15:59:59.999, @T20:59:59.999, @T15:59:59.999, @T20:59:59.999 })</expression>
			<output>6</output>
		</test>
		<test name="LengthNullList" version="1.0">
			<capability code="list-operators" />
			<expression>Length(null as List&lt;Any&gt;)</expression>
			<output>0</output>
		</test>
	</group>
	<group name="Equivalent" version="1.0">
		<capability code="list-operators" />
		<test name="EquivalentEmptyAndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{} ~ {}</expression>
			<output>true</output>
		</test>
		<test name="EquivalentABCAndABC" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } ~ { 'a', 'b', 'c' }</expression>
			<output>true</output>
		</test>
		<test name="EquivalentABCAndAB" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } ~ { 'a', 'b' }</expression>
			<output>false</output>
		</test>
		<test name="EquivalentABCAnd123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } ~ { 1, 2, 3 }</expression>
			<output>false</output>
			<!-- TODO: make Translator resolve isolated Equivalent operator signatures -->
		</test>
		<test name="Equivalent123AndABC" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } ~ { 'a', 'b', 'c' }</expression>
			<output>false</output>
			<!-- TODO: make Translator resolve isolated Equivalent operator signatures -->
		</test>
		<test name="Equivalent123AndString123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } ~ { '1', '2', '3' }</expression>
			<output>false</output>
			<!-- TODO: make Translator resolve isolated Equivalent operator signatures -->
		</test>
		<test name="EquivalentDateTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10), null} ~ {DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10), null}</expression>
			<output>true</output>
		</test>
		<test name="EquivalentDateTimeNull" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)} ~ {DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10), null}</expression>
			<output>false</output>
		</test>
		<test name="EquivalentDateTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)} ~ {DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 1)}</expression>
			<output>false</output>
		</test>
		<test name="EquivalentTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999 } ~ { @T15:59:59.999, @T20:59:59.999 }</expression>
			<output>true</output>
		</test>
		<test name="EquivalentTimeNull" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999 } ~ { @T15:59:59.999, @T20:59:59.999, null }</expression>
			<output>false</output>
		</test>
		<test name="EquivalentTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999 } ~ { @T15:59:59.999, @T20:59:59.995 }</expression>
			<output>false</output>
		</test>
	</group>
	<group name="NotEqual" version="1.0">
		<capability code="list-operators" />
		<test name="NotEqualEmptyAndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{} != {}</expression>
			<output>false</output>
		</test>
		<test name="NotEqualABCAndABC" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } != { 'a', 'b', 'c' }</expression>
			<output>false</output>
		</test>
		<test name="NotEqualABCAndAB" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } != { 'a', 'b' }</expression>
			<output>true</output>
		</test>
		<test name="NotEqualABCAnd123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 'a', 'b', 'c' } != { 1, 2, 3 }</expression>
			<output>true</output>
			<!-- TODO: make Translator resolve isolated Equivalent operator signatures -->
		</test>
		<test name="NotEqual123AndABC" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } != { 'a', 'b', 'c' }</expression>
			<output>true</output>
			<!-- TODO: make Translator resolve isolated Equivalent operator signatures -->
		</test>
		<test name="NotEqual123AndString123" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } != { '1', '2', '3' }</expression>
			<output>true</output>
			<!-- TODO: make Translator resolve isolated Equivalent operator signatures -->
		</test>
		<test name="NotEqualDateTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11, 0, 0, 0, 0), DateTime(2012, 5, 10, 0, 0, 0, 0), DateTime(2014, 12, 10, 0, 0, 0, 0)} != {DateTime(2001, 9, 11, 0, 0, 0, 0), DateTime(2012, 5, 10, 0, 0, 0, 0), DateTime(2014, 12, 1, 0, 0, 0, 0)}</expression>
			<output>true</output>
		</test>
		<test name="NotEqualDateTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11, 0, 0, 0, 0), DateTime(2012, 5, 10, 0, 0, 0, 0), DateTime(2014, 12, 10, 0, 0, 0, 0)} != {DateTime(2001, 9, 11, 0, 0, 0, 0), DateTime(2012, 5, 10, 0, 0, 0, 0), DateTime(2014, 12, 10, 0, 0, 0, 0)}</expression>
			<output>false</output>
		</test>
		<test name="NotEqualTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999 } = { @T15:59:59.999, @T20:59:59.999 }</expression>
			<output>true</output>
		</test>
		<test name="NotEqualTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999 } = { @T15:59:59.999, @T20:59:49.999 }</expression>
			<output>false</output>
		</test>
	</group>
	<group name="ProperContains" version="1.0">
		<capability code="list-operators" />
		<test name="ProperContainsNullRightFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{'s', 'u', 'n'} properly includes null</expression>
			<output>false</output>
		</test>
		<test name="ProperContainsNullRightTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{'s', 'u', 'n', null} properly includes null</expression>
			<output>true</output>
		</test>
		<test name="ProperContainsTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59, @T20:59:59.999, @T20:59:49.999 } properly includes @T15:59:59</expression>
			<output>true</output>
		</test>
		<test name="ProperContainsTimeNull" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999, @T20:59:49.999 } properly includes @T15:59:59</expression>
			<output>null</output>
		</test>
	</group>
	<group name="ProperIn" version="1.0">
		<capability code="list-operators" />
		<test name="ProperInNullRightFalse" version="1.0">
			<capability code="list-operators" />
			<expression>null properly included in {'s', 'u', 'n'}</expression>
			<output>false</output>
		</test>
		<test name="ProperInNullRightTrue" version="1.0">
			<capability code="list-operators" />
			<expression>null properly included in {'s', 'u', 'n', null}</expression>
			<output>true</output>
		</test>
		<test name="ProperInTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>@T15:59:59 properly included in { @T15:59:59, @T20:59:59.999, @T20:59:49.999 }</expression>
			<output>true</output>
		</test>
		<test name="ProperInTimeNull" version="1.0">
			<capability code="list-operators" />
			<expression>@T15:59:59 properly included in { @T15:59:59.999, @T20:59:59.999, @T20:59:49.999 }</expression>
			<output>null</output>
		</test>
	</group>
	<group name="ProperlyIncludes" version="1.0">
		<capability code="list-operators" />
		<test name="ProperIncludesEmptyAndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{} properly includes {}</expression>
			<output>false</output>
		</test>
		<test name="ProperIncludesListNullAndListNull" version="1.0">
			<capability code="list-operators" />
			<expression>{null} properly includes {null}</expression>
			<output>false</output>
		</test>
		<test name="ProperIncludes123AndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{1, 2, 3} properly includes {}</expression>
			<output>true</output>
		</test>
		<test name="ProperIncludes123And2" version="1.0">
			<capability code="list-operators" />
			<expression>{1, 2, 3} properly includes {2}</expression>
			<output>true</output>
		</test>
		<test name="ProperIncludes123And4" version="1.0">
			<capability code="list-operators" />
			<expression>{1, 2, 3} properly includes {4}</expression>
			<output>false</output>
		</test>
		<test name="ProperIncludesDateTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)} properly includes {DateTime(2012, 5, 10), DateTime(2014, 12, 10)}</expression>
			<output>true</output>
		</test>
		<test name="ProperIncludesDateTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)} properly includes {DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)}</expression>
			<output>false</output>
		</test>
		<test name="ProperIncludesTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999, @T20:59:49.999 } properly includes { @T15:59:59.999, @T20:59:59.999 }</expression>
			<output>true</output>
		</test>
		<test name="ProperIncludesTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999, @T20:59:49.999 } properly includes { @T15:59:59.999, @T20:59:59.999, @T14:59:22.999 }</expression>
			<output>false</output>
		</test>
		<test name="ProperlyIncludesNullLeft" version="1.0">
			<capability code="list-operators" />
			<expression>null properly includes {2}</expression>
			<output>null</output>
		</test>
	</group>
	<group name="ProperlyIncludedIn" version="1.0">
		<capability code="list-operators" />
		<test name="ProperIncludedInEmptyAndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{} properly included in {}</expression>
			<output>false</output>
		</test>
		<test name="ProperIncludedInListNullAndListNull" version="1.0">
			<capability code="list-operators" />
			<expression>{null} properly included in {null}</expression>
			<output>false</output>
		</test>
		<test name="ProperIncludedInEmptyAnd123" version="1.0">
			<capability code="list-operators" />
			<expression>{} properly included in {1, 2, 3}</expression>
			<output>true</output>
		</test>
		<test name="ProperIncludedIn2And123" version="1.0">
			<capability code="list-operators" />
			<expression>{2} properly included in {1, 2, 3}</expression>
			<output>true</output>
		</test>
		<test name="ProperIncludedIn4And123" version="1.0">
			<capability code="list-operators" />
			<expression>{4} properly included in {1, 2, 3}</expression>
			<output>false</output>
		</test>
		<test name="ProperIncludedInDateTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2012, 5, 10), DateTime(2014, 12, 10)} properly included in {DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)}</expression>
			<output>true</output>
		</test>
		<test name="ProperIncludedInDateTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)} properly included in {DateTime(2001, 9, 11), DateTime(2012, 5, 10), DateTime(2014, 12, 10)}</expression>
			<output>false</output>
		</test>
		<test name="ProperIncludedInTimeTrue" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999 } properly included in { @T15:59:59.999, @T20:59:59.999, @T20:59:49.999 }</expression>
			<output>true</output>
		</test>
		<test name="ProperIncludedInTimeFalse" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999, @T14:59:22.999 } properly included in { @T15:59:59.999, @T20:59:59.999, @T20:59:49.999 }</expression>
			<output>false</output>
		</test>
		<test name="ProperlyIncludedInNulRight" version="1.0">
			<capability code="list-operators" />
			<expression>{'s', 'u', 'n'} properly included in null</expression>
			<output>null</output>
		</test>
	</group>
	<group name="SingletonFrom" version="1.0">
		<capability code="list-operators" />
		<test name="SingletonFromEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>singleton from {}</expression>
			<output>null</output>
		</test>
		<test name="SingletonFromListNull" version="1.0">
			<capability code="list-operators" />
			<expression>singleton from {null}</expression>
			<output>null</output>
		</test>
		<test name="SingletonFrom1" version="1.0">
			<capability code="list-operators" />
			<expression>singleton from { 1 }</expression>
			<output>1</output>
		</test>
		<test name="SingletonFrom12" version="1.0">
			<capability code="list-operators" />
			<expression invalid="true">singleton from { 1, 2 }</expression>
			<!-- EXPECT: Expected a list with at most one element, but found a list with multiple elements. -->
		</test>
		<test name="SingletonFromDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>singleton from { DateTime(2012, 5, 10) }</expression>
			<output>@2012-05-10T</output>
		</test>
		<test name="SingletonFromTime" version="1.0">
			<capability code="list-operators" />
			<expression>singleton from { @T15:59:59.999 }</expression>
			<output>@T15:59:59.999</output>
		</test>
	</group>
	<group name="Skip" version="1.0">
		<capability code="list-operators" />
		<test name="SkipNull" version="1.0">
			<capability code="list-operators" />
			<expression>Skip(null, 3)</expression>
			<output>null</output>
		</test>
		<test name="SkipEven" version="1.0">
			<capability code="list-operators" />
			<expression>Skip({1,2,3,4,5}, 2)</expression>
			<output>{3, 4, 5}</output>
		</test>
		<test name="SkipOdd" version="1.0">
			<capability code="list-operators" />
			<expression>Skip({1,2,3,4,5}, 3)</expression>
			<output>{4, 5}</output>
		</test>
		<test name="SkipNone" version="1.0">
			<capability code="list-operators" />
			<expression>Skip({1,2,3,4,5}, 0)</expression>
			<output>{1,2,3,4,5}</output>
		</test>
		<test name="SkipAll" version="1.0">
			<capability code="list-operators" />
			<expression>Skip({1,2,3,4,5}, 5)</expression>
			<output>{}</output>
		</test>
	</group>
	<group name="Tail" version="1.0">
		<capability code="list-operators" />
		<test name="TailNull" version="1.0">
			<capability code="list-operators" />
			<expression>Tail(null)</expression>
			<output>null</output>
		</test>
		<test name="TailEven" version="1.0">
			<capability code="list-operators" />
			<expression>Tail({1,2,3,4})</expression>
			<output>{2,3,4}</output>
		</test>
		<test name="TailOdd" version="1.0">
			<capability code="list-operators" />
			<expression>Tail({1,2,3,4,5})</expression>
			<output>{2,3,4,5}</output>
		</test>
		<test name="TailEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>Tail({})</expression>
			<output>{}</output>
		</test>
		<test name="TailOneElement" version="1.0">
			<capability code="list-operators" />
			<expression>Tail({1})</expression>
			<output>{}</output>
		</test>
	</group>
	<group name="Take" version="1.0">
		<capability code="list-operators" />
		<test name="TakeNull">
			<capability code="list-operators" />
			<expression>Take(null, 3)</expression>
			<output>null</output>
		</test>
		<test name="TakeNullEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>Take({1,2,3}, null as Integer)</expression>
			<output>{}</output>
		</test>
		<test name="TakeEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>Take({1,2,3}, 0)</expression>
			<output>{}</output>
		</test>
		<test name="TakeEven" version="1.0">
			<capability code="list-operators" />
			<expression>Take({1,2,3,4}, 2)</expression>
			<output>{1, 2}</output>
		</test>
		<test name="TakeOdd" version="1.0">
			<capability code="list-operators" />
			<expression>Take({1,2,3,4}, 3)</expression>
			<output>{1, 2, 3}</output>
		</test>
		<test name="TakeAll" version="1.0">
			<capability code="list-operators" />
			<expression>Take({1,2,3,4}, 4)</expression>
			<output>{1, 2, 3, 4}</output>
		</test>
	</group>
	<group name="Union" version="1.0">
		<capability code="list-operators" />
		<test name="UnionEmptyAndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{} union {}</expression>
			<output>{}</output>
		</test>
		<test name="UnionListNullAndListNull" version="1.0">
			<capability code="list-operators" />
			<expression>{ null } union { null }</expression>
			<output>{null}</output>
		</test>
		<test name="Union123AndEmpty" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } union {}</expression>
			<output>{1, 2, 3}</output>
		</test>
		<test name="Union123And2" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } union { 2 }</expression>
			<output>{1, 2, 3}</output>
		</test>
		<test name="Union123And4" version="1.0">
			<capability code="list-operators" />
			<expression>{ 1, 2, 3 } union { 4 }</expression>
			<output>{1, 2, 3, 4}</output>
		</test>
		<test name="UnionDateTime" version="1.0">
			<capability code="list-operators" />
			<expression>{ DateTime(2001, 9, 11)} union {DateTime(2012, 5, 10), DateTime(2014, 12, 10) }</expression>
			<output>{@2001-09-11T, @2012-05-10T, @2014-12-10T}</output>
		</test>
		<test name="UnionTime" version="1.0">
			<capability code="list-operators" />
			<expression>{ @T15:59:59.999, @T20:59:59.999, @T12:59:59.999 } union { @T10:59:59.999 }</expression>
			<output>{@T15:59:59.999, @T20:59:59.999, @T12:59:59.999, @T10:59:59.999}</output>
		</test>
	</group>
</tests>
